% The data generated by this script should be used with the get_data_slice.m
% function, which returns the data according to the format saved in here.
%
% This generates four matrices. Two for training and and two for testing.
% trnDat - the training data predictors (X)
% trnLbl - the training data responses (y) (target)
% tstDat, tstLbl - same for testing data (remaining after split), see below
%
%
% Each row contains the concatenated slices of all the sensors.
% Each slice has a specific window size of w for trnDat and tstDat.
% Hence, each row will have num_sensors * window_size entries
%
% Sensor  |        A                 B                      X
% Slice1  | [A_1 A_2 ... A_w] [B_1 B_2 ... B_w] ... [X_1 X_2 ... X_w]
% Slice2  | .....
%
% For the responses, each column in the matrix is a response variable
% thus there will be as many columns as sensors
% Each row in the Dat matrix corresponds to a row in the Lbl matrix
%

%% Loading data

load tdata/VolumeData_tensor.mat
noDays = size(data,2);
noSensors = size(data,1);
noObs = size(data,3);


%% ----------------------- configure options here ------------------------------

% Sliding window width
winWidth = 11; 

% Slide step for the window (this is not the response size)
slideStep = 1;

% The percentage of the data used for training and parameter tuning
trainPercent = 0.7; 

% The threshold for splitting into high/low traffic volume classification
quantilePercent = 0.85; 

%% ---- generate (nodays * 96) x noSensors ----
% e.g. concatenate data for one sensor for all time,
% columns are timeseries samples, each row is a sensor / feature

totalObs = noDays * noObs;
allSensors = zeros(totalObs, noSensors);
for i = 1:noSensors
    d = squeeze(data(i,:,:))';     
     
%     % replace missing data with average reading
%     thezeros = sum(d,1)==0;
%     d(:,thezeros) = squeeze(baseline_means(i, dayz(thezeros),:))';

    allSensors(:,i) = d(:);
end


%% ------- rescale data
[tmp, mapMinMax] = mapminmax(allSensors', -0.9999, 0.9999);
%[tmp, mapMinMax] = mapstd(allSensors');
allSensors = tmp';

clear d data HF_list tmp;

% ---------------------- no need to edit after this point ----------------------

%% split into train / validation

testSize = max(winWidth + 1, floor((1 - trainPercent) * totalObs));
trainSize = totalObs - testSize;

trainSet = allSensors(1:trainSize,:);
testSet = allSensors(trainSize+1:totalObs,:);

%clear allSensors;

%% ---- reshape dataset into synchronised sliding windows ----
% for all sensors and target value for each time step
% gather all data into trainining and testing datasets

numStepsTrn = (trainSize - winWidth) / slideStep; % Number of windows train
numStepsTst = (testSize - winWidth) / slideStep; % Number of windows test

% preallocate
trnDat = zeros(numStepsTrn, noSensors*(winWidth-1));
trnLbl = zeros(numStepsTrn, noSensors);
tmp = zeros(winWidth-1, noSensors);

tic;
for i = 1:numStepsTrn % sliding window index through all time series
    for j = 1:noSensors % gather data for all sensors into one row
        tmp(:,j) = trainSet(i:i+winWidth-2,j);
        % each row is a new time step. the values in the rows are the
        % outputs for each sensor, corresponding to the td / (winWidth-1)
        trnLbl(i,j) = trainSet(i+winWidth-1,j);
    end
    % this contains the values of the input sliding window
    % for each sensor, concatenated into a single vector
    % every winWidth-1, a new sensor reading begins
    trnDat(i,:) = reshape(tmp, 1, noSensors*(winWidth-1));
end
toc;
disp('Finished processing train data');

clear trainSet; 

%% same for test data

tstDat = zeros(numStepsTst, noSensors*(winWidth-1));
tstLbl = zeros(numStepsTst, noSensors);
tmp = zeros(winWidth-1, noSensors);

tic;
for i = 1:numStepsTst % sliding window index through all time series
    for j = 1:noSensors % gather data for all sensors into one row
        tmp(:,j) = testSet(i:i+winWidth-2,j);
        % each row is a new time step. the values in the rows are the
        % outputs for each sensor, corresponding to the td / (winWidth-1)
        tstLbl(i,j) = testSet(i+winWidth-1,j);
    end
    % this contains the values of the input sliding window
    % for each sensor, concatenated into a single vector
    % every winWidth-1, a new sensor reading begins
    tstDat(i,:) = reshape(tmp, 1, noSensors*(winWidth-1));
end
toc;
disp('Finished processing test data');

%% ----- generate 0/1 class labels  -----

trnLblBin = zeros(numStepsTrn, noSensors);
tstLblBin = zeros(numStepsTst, noSensors);

for i = 1:noSensors
    threshold = quantile(allSensors(:,i), quantilePercent);
    trnLblBin(:,i) = (trnLbl(:,i) > threshold);
    tstLblBin(:,i) = (tstLbl(:,i) > threshold);
end

% total high volume, percentage:
percentHighTrn = sum(sum(trnLblBin))/numel(trnLblBin)
percentHighTst = sum(sum(tstLblBin))/numel(tstLblBin)

clear testSet i j tmp allSensors;
clear baseline_*;

%%

% save to disk with -v7.3 (HDFS) so we can load things partially with matfile command
save(strcat('tdata/VolumeData_Window_',num2str(winWidth),'_norm01.mat'), '-v7.3'); 

%% test for this script
% data = [1:19 ; (1:19)*10]
% construct_sliding_dataset
% trnDat
% trnLbl
% tstDat
% tstLbl
